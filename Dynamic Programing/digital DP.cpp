// 数位 DP，统计1~x中每个数位出现的次数
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 16;
ll ten[N], dp[N]; // ten[i]：10^i, dp[i]: i 位数的数位统计（dp[1]:1, dp[2]：20, dp[3]：300, ...）
int digit[N], cnt[N]; // digit[i]：x 的每个数位，cnt[i]：每个数位 i 出现的次数

void init() {
    ten[0] = 1;
    for (int i = 1; i < N; i++) {
        dp[i] = i * ten[i - 1];
        ten[i] = ten[i - 1] * 10;
    }
}

void solve(ll x) { // 将1~x的数位统计结果放到 cnt 数组
    int len = 0; // 数字x的位数
    while (x) {
        digit[++len] = x % 10;
        x /= 10;
    }
    // 比如对于324，第一轮循环统计0~300，第二轮0~20，第三轮0~4
    for (int i = len; i; i--) { // 从高到低处理 x 的每位
        // 统计除了最高位之外的位出现的次数
        for (int j = 0; j <= 9; j++) cnt[j] += dp[i - 1] * digit[i]; // 统计00~99 * 3的部分
        for (int j = 0; j < digit[i]; j++) cnt[j] += ten[i - 1]; // 统计000~099、100~199、200~299中的最高位0、1、2
        ll num = 0;
        for (int j = i - 1; j >= 1; j--) num = num * 10 + digit[j]; // 统计300~324中的最高位3出现的次数：即00~24 = 24 + 1
        cnt[digit[i]] += num + 1; // 24 + 1个最高位3
        cnt[0] -= ten[i - 1]; // 特判前导零：000~099中多了100次0
    }
}

/**
 * 注意：最后一行的cnt[0] -= ten[i - 1]不能合并到第28行去：即不能写成：for (int j = 1; j < digit[i]; j++) {...}，然后不写第32行
 * 不难发现：这并不等价：当digit[i]的值是0时，在第28行不仅不会增加，第32行还会减少；
 * 这是因为，第32行中的减去ten[i - 1]是为了减去000~099、00~09、0~0（总共要减len次）中最高位中0的个数。所以每次循环都要减去一次ten[i - 1]。
 * 讲得详细一点：对于1、2、3、……、9而言，在00~99中的出现次数ten[2]，就等于在1~99中的出现次数，这是没差别的；但是0不一样，还得再减去00~09中的前导零，0~0中的前导零；
 * 而对于一个数x（如324），总共多计算了多少次前导零呢？显然只有在000~099、00~09、0~0中多计算了，需要减去。
 * 对于其它数也是一样不管是124、411还是其它的任何三位数，一定是在000~099、00~09、0~0这三个情况下多计算了前导零。
 * 规律就是len位数减去len次ten[i - 1]，其中 i 属于 [1, len]；
 */